# Authentication

The API uses JWT for authentication, but that's only part of the story. As the users don't have application-specific credentials nor social logins, how do they authenticate themselves and get a JWT? Also, what about the refresh tokens? These questions should hopefully be answered in this document, which details the authentication solution we devised for the project.

As this is a web3 application, the user would expect to use their wallet as a credential. However, how can we, in the backend, verify the wallet of the user issuing the HTTP requests? We do so verifying cryptographically signed messages, and then checking that the key used to sign belongs to the user wallet. However, that's trickier than it seems, as our frontend needs to use the keys to sign a message, and if our app could simply sign any message with the user's private keys, that would be a huge security concern! That's why when the user connects their wallet in our site, an application-specific key pair gets generated. Then our frontend can have keys it can use for signing without the security of the user being compromised (as we can only sign messages to interact with our own smart-contracts), and our backend can then assert that the keys both belong to the user's wallet and have permission to operate in the MMC smart-contracts. Note that the key takes the refresh token role: whenever the token expires, the user can then sign a new message to get another JWT.

The only question left is what message should the user sign. The more specific it is, the less risk is there that some attacker could forge a fake signature (e.g. in a key-only attack setting). The go-to solution would be for the server to return a nonce (a random number), that the user would then have to sign. However that requires some state-management, as the backend would have to remember the nonces it gave to each user (and when), and that would complicate our infrastructure just to block a completely unreasonable attack vector.

The solution we devised consists of the user signing their current timestamp, and if it arrives within a reasonable timeframe to the server, we authenticate them, giving a JWT. Of course, that's not as secure as the nonce, because a sophisticated attacker could try to forge a signature for a future timestamp well in advance. However, as we mentioned, that unfeasible, as that would require a huge amount of computational power, and such a resourceful attacker does not coincide with the risk-profile of this application.

A potential improvement would be for the user to first get a criptographically signed nonce from the server, which it could then embed in the message's payload, and reply to the server with the signed message (containing the nonce) together with the signed nonce, which the server could in turn verify without requiring any additional infrastructure, besides a key pair. That would of course increase the `/auth/login` latency by around 100ms, as the server would have to verify an additional signature. (Of course it would also require an additional roundtrip, but that's also a given in the original nonce solution.)